# 다양한 경로로 들어오는 파라미터들 정리

## Request Body
### pydantic Basemodel
-pydantic 을 사용해 dto 를 정의
-리퀘스트 바디의 json 을 자동으로 변환
-타입에 맞는지 밸리데이션 체크도 자동으로 수행
```python
from pydantic import BaseModel

class BlogModel(BaseModel):
    title: str
    content: str
    published: Optional[bool]
    comments_number: int

@router.post("/new")
def create_blog(blog: BlogModel):
    blog.title
    return blog
```

## Path & Query Parameter
- RequestBody + Path variable + Query Param 3단 혼합도 가능
```python
@router.post('/new/{id}')
def create_blog(
    blog:BlogModel,
    id:int,
    version:int = 1,
    ):
```

## Parameter Metadata
- metadata : 추가 정보. 파라미터에 대한 추가 정보를 넣을 수 있다.
- Query, Path, Body import 로 실 구현
- 기본값도 함께 넣어준다.
```python
#임포트를 통해 구현
from fastapi import Query
#기본형
@router.post('/new/{id}/comment')
def create_comment(blog: BlogModel, id:int, comment_id: int = Query(None)):

#고급형
@router.post("/new/{id}/comment")
def create_comment(
    blog: BlogModel,
    id: int,
    comment_id: int = Query(
        None,
        title="Id of the comment", # 사실 타이틀은 Swagger 에 표시 안 됨
        description="some description for comment_id", # 이건 표시됨
    ),
    alias='commentId', #js변수 같은거랑 호환하려면 좋음
    deprecated=True #안쓰는 인자에 넣어두면 좋음
):
    pass
```
- 파라미터를 필수로 주고 싶을 때?
```python
## 기본적으로 메타데이터에 기본값을 넣어버리면 당연히 옵셔널이 되어버림
from fastapi import Body
@router.post('/new/{id}/comment')
def create_comment(comment_id: int = Body('hi, how are you')):

## ...을 쓰면 필수가 됨
from fastapi import Body
@router.post('/new/{id}/comment')
def create_comment(comment_id: int = Body(...)):
```

## Validators
- 메타데이터로 데이터 제약사항을 제공 가능(e.g. Min Length)
```python
content: str = Body(
    ...,
    min_length=10,
    max_length=50,
    regex=r'^[a-z\s]*$', #정규표현식으로도 검증 가능
    )
```

## Multiple values(List / Array)
- 키 하나에 밸류가 여럿
- 쿼리 파라미터에서만 가능
- v=1.0, v=1.2, v=3 같은 식으로...
```http
localhost:8001/blog/new/2/comment?commentId=4&v=1.0&v=1.2&v=3
```
```python
# 인자를 이런 식으로 적어두면, 리스트로 받아올 수 있다.
v: Optional[List[str]] = Query(None)
```
## Number Validators
- 숫자 검증에 특화된 Validators.
```python
comment_id: int = Path(None, gt=5) #greater than
```
```python
comment_id: int = Path(None, ge=5) #greater or equal
```
```python
comment_id: int = Path(None, lt=5) #less than
```
```python
comment_id: int = Path(None, le=5) #less or equal
```
## Complex subtypes(사용자 정의 타입을 다른 타입의 속성으로 사용하기)
- str, int 같은 primitive 타입 말고, pydantic으로 정의한 타입 등, 복잡한 서브타입을 인자로 받기.
```python
# 파이썬이 사전에 정해둔 타입들(typing)도 당연히 받을 수 있다.
class BlogModel(BaseModel):
    title: str
    content: str
    nb_comments: int
    published: Optional[bool]
    tags: List[str] = [] # 객체 내부 속성을 리스트로 받기. 기본값 []
    metadata: Dict[str,str] = {"k1","v1"} # Dict 로 받기도 가능
```

```python
# 서브타입을 받으려면...
class Image(BaseModel): # 커스텀 서브타입을 선언한 뒤
    url: str
    alias: str
class BlogModel(BaseModel):
    title: str
    content: str
    nb_comments: int
    published: Optional[bool]
    tags: List[str] = []
    metadata: Dict[str,str] = {"k1","v1"}
    image: Optional[Image] # 그 타입을 속성으로 갖는 객체를 받기도 가능
```